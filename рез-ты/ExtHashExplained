====================================
Результаты бенчмарков Extendible Hash
====================================

Окружение:
- JMH 1.37
- JVM: OpenJDK 11.0.27 (HotSpot)
- Warmup: 3 итерации по 10 c
- Измерение: 5 итераций по 10 c
- Threads: 1
- Benchmark mode: Average time (ms/op)

-------------------------------
Вводные цифры (средние значения)
-------------------------------
insert10k          ≈ 8699 ms/op
insertThenRead10k  ≈ 8802 ms/op
insertSaveLoad10k  ≈ 10713 ms/op
loadFromDisk10k    ≈ 2084 ms/op
saveReadyHash10k   ≈ 8.98 ms/op

-------------------------
Интерпретация результатов
-------------------------

1. **insert10k (~8.7 s)**
   - Чистая вставка 10k пар в новую таблицу.
   - Время довольно высокое: каждая вставка сопровождается персистентностью бакета
     (запись на диск), что создаёт узкое место.
   - Накладные расходы видны: на 10k операций уходит порядка 8.7 секунд,
     то есть ~0.87 ms на одну вставку.

2. **insertThenRead10k (~8.8 s)**
   - Вставка + последовательное чтение всех элементов.
   - Время лишь немного выше чистой вставки.
   - Чтение из памяти незначительно добавляет нагрузки,
     что подтверждает: основная стоимость – операции записи на диск.

3. **insertSaveLoad10k (~10.7 s)**
   - Полный сценарий: вставка 10k, сериализация каркаса в файл, загрузка обратно и проверка.
   - На 20% медленнее, чем insert10k.
   - Увеличение времени объясняется дополнительной сериализацией каталога
     и повторным чтением/инициализацией объектов.

4. **loadFromDisk10k (~2.1 s)**
   - Чистая загрузка готовой таблицы с 10k элементов и чтение всех ключей.
   - Существенно быстрее, чем вставка: чтение с диска и обход каталога ≈ 2 секунды,
     тогда как построение с нуля ≈ 8–10 секунд.
   - Подтверждает, что стратегия «сохранить и переиспользовать» выгоднее,
     чем каждый раз строить заново.

5. **saveReadyHash10k (~9 ms)**
   - Сохранение уже заполненной структуры.
   - Заметно быстрее, чем операции вставки или загрузки.
   - Сериализация метаданных «каркаса» почти не стоит ресурсов,
     основная работа уже сделана при заполнении бакетов.

----------------------
Общие выводы
----------------------
- **Узкое место**: операции вставки, так как каждая мутация вызывает персистентность бакета.
- **Чтение** относительно дешёвое — после загрузки структура доступна быстро.
- **Лучший сценарий использования**: строить таблицу один раз, сохранить, а потом много раз загружать для чтения.
- **Оптимизация**: можно рассмотреть буферизацию/батчинг дисковых операций (но это изменит семантику «per-mutation persistence»).
