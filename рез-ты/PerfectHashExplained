====================================
Результаты бенчмарков Perfect Hash
====================================

Окружение:
- JMH 1.37
- JVM: OpenJDK 11.0.27 (HotSpot)
- Warmup: 5 итераций по 10 c
- Измерение: 5 итераций по 10 c
- Threads: 1
- Benchmark mode: Average time (ms/op)
- Нагрузка: 10 000 ключей (см. код бенчмарка)

-------------------------------
Вводные цифры (средние значения)
-------------------------------
testBuildPerfectHashTable  ≈ 53.0 ms/op
testLookupKey              ≈ 1e-5 ms/op (мгновенно)

-------------------------
Интерпретация результатов
-------------------------

1. **testBuildPerfectHashTable (~53 ms)**
   - Измеряет построение совершенной хеш-таблицы для 10k ключей.
   - Задача нетривиальна: требуется перебор случайных параметров до устранения коллизий.
   - Среднее время порядка 50 миллисекунд, но разброс заметный (от 46 до 67 ms, доверительный интервал широкий).
   - Высокий разброс объясняется вероятностной природой метода: в зависимости от случайного сида удачный «perfect» хеш может быть найден быстрее или медленнее.

2. **testLookupKey (~1e-5 ms)**
   - Проверка наличия ключа в уже построенной таблице.
   - Практически мгновенная операция: обращение по индексу в массиве без коллизий.
   - Это и есть основное преимущество perfect hashing: поиск в O(1) без дополнительной обработки.

----------------------
Общие выводы
----------------------
- Стоимость построения PerfectHash сравнительно велика и варьируется, но она единоразовая.
- Зато результатом является структура с мгновенными поисковыми операциями.
- Подходит для сценариев: множество ключей известно заранее, требуется быстрый поиск, вставки/удаления не нужны.
- Важно: при увеличении числа ключей построение будет дорожать примерно квадратично (так как размер таблицы m = n²).