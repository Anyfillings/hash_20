===========================================
Общий план защиты лабораторной работы
===========================================

1. Введение (2–3 минуты)
   - Цель лабораторной: реализовать и сравнить разные алгоритмы хеширования:
     * Extendible Hash (динамическая хеш-таблица),
     * Perfect Hash (хеш без коллизий для фиксированного множества),
     * MinHash (вероятностный метод оценки Jaccard-сходства).
   - В проекте присутствуют:
     * классы-реализации,
     * вспомогательные структуры (бакеты),
     * демо (`Main.java`),
     * бенчмарки JMH.
   - Практическая ценность: показать компромиссы между временем построения, временем поиска и возможностью изменять данные.

2. Теоретическая часть (5–6 минут)
   **Extendible Hashing**
   - Основан на каталоге указателей (`directory`), размер которого определяется глобальной глубиной `globalDepth`.
   - При переполнении бакета (`ExtHashBucket.isFull()`), вызывается метод `split(int dirIndex)`, который:
     * увеличивает локальную глубину переполненного бакета,
     * при необходимости удваивает каталог (`directory.addAll(...)`),
     * перераспределяет элементы (`snapshotItems()`, `clear()`, повторные `put()`).
   - Хеш-функция реализована в приватном методе `hash(Object key)`, индекс каталога считается в `dirIndexForHash(int h)`.

   **Perfect Hashing**
   - В `PerfectHash(List<K> keys)` выбирается размер таблицы `m = n²`.
   - Цикл с `Random seed` пробует параметры до тех пор, пока не исчезнут коллизии.
   - Метод `contains(K key)` вычисляет индекс через `Objects.hash(key, seed) % m` и проверяет точное совпадение.

   **MinHash**
   - В `MinHash(int numHash, long seed)` генерируются параметры `a[i], b[i]` для хеш-функций вида `(a·x + b) mod P`.
   - Метод `signatureFor(Set<Integer> set)` строит подпись длины `numHash` (минимальные значения).
   - Метод `estimateJaccard(int[] s1, int[] s2)` сравнивает две подписи по позициям.
   - Вспомогательные методы: `hashString`, `toIntSet`, `shingles`.

3. Особенности реализации (5 минут)
   **ExtendibleHash.java**
   - `put(K key, V value)` — вставка с учётом split.
   - `get(K key)` — получение значения по ключу.
   - `remove(K key)` — удаление с персистентностью.
   - `printStatus()` — вывод состояния: глобальная глубина, бакеты, их файлы и количество элементов.
   - `saveToFile()` и `loadFromFile()` — сериализация/десериализация каркаса.

   **ExtHashBucket.java**
   - Конструктор создаёт пустой бакет и сразу сохраняет его на диск (`persist()`).
   - `put/remove/clear` — модифицируют данные и вызывают `persist()`.
   - `snapshotItems()` — копия содержимого при split.
   - `load(...)` — загрузка бакета с диска, восстанавливает состояние и повторно делает `persist()`.

   **Bucket.java**
   - Упрощённая версия бакета без персистентности, используется для справки.

   **PerfectHash.java**
   - Конструктор перебирает seed, пока не построит таблицу без коллизий.
   - Таблица `Object[] table` хранит ключи напрямую.
   - Метод `contains(K key)` — мгновенный поиск.

   **MinHash.java**
   - Методы для построения подписи и утилиты для работы со строками.
   - Сложность `O(|set| * numHash)` для построения подписи.

4. Параметры тестов (2–3 минуты)
   **ExtHashBenchmark.java**
   - N = 10 000 операций, bucket size = 4.
   - Сценарии:
     * `insert10k`: только вставка,
     * `insertThenRead10k`: вставка и чтение,
     * `saveReadyHash10k`: сериализация готовой таблицы,
     * `loadFromDisk10k`: загрузка таблицы с диска,
     * `insertSaveLoad10k`: end-to-end сценарий.
   - Стейт-классы: `HashState`, `ReadyHashState`, `PersistedFileState`.

   **MinHashBenchmark.java**
   - Параметры: numDocs=100, numHash=64, setSize=800, universe=50000.
   - `testBuildSignatures`: строит подписи для корпуса документов.
   - `testEstimateSimilarity`: оценивает схожесть двух случайных документов.

   **PerfectHashBenchmark.java**
   - keynum=10 000.
   - `testBuildPerfectHashTable`: построение таблицы.
   - `testLookupKey`: поиск случайного ключа.

5. Результаты бенчмарков (4–5 минут)
   - **Extendible Hash:**
     * insert10k ≈ 8.7 s,
     * insertThenRead10k ≈ 8.8 s,
     * insertSaveLoad10k ≈ 10.7 s,
     * loadFromDisk10k ≈ 2.1 s,
     * saveReadyHash10k ≈ 9 ms.
     → Вставка дорога из-за персистентности, чтение после загрузки быстрое.

   - **MinHash:**
     * testBuildSignatures ≈ 5.9 ms,
     * testEstimateSimilarity ≈ 1e-5 ms.
     → Построение дешёвое, сравнение сверхбыстрое.

   - **Perfect Hash:**
     * testBuildPerfectHashTable ≈ 53 ms,
     * testLookupKey ≈ 1e-5 ms.
     → Построение дороже, но поиск мгновенный.

6. Сильные и слабые стороны (2–3 минуты)
   - Extendible Hash: гибкость и поддержка динамики, но низкая скорость вставок.
   - Perfect Hash: мгновенный поиск, но не работает для изменяемых множеств.
   - MinHash: дешёвая аппроксимация, но результат неточный.

7. Демонстрация (2 минуты)
   - `Main.java`: создаёт `ExtendibleHash`, вставляет пары, печатает состояние, выполняет удаление.
   - В `ext-hash-data/` появляются файлы `bucket_*.bin`.

8. Заключение (1 минута)
   - Подытожить: каждая структура имеет свои сценарии применения.
   - Сказать, что лабораторная показывает связь теории и практики.

------------------------------------
Дополнительные вопросы экзаменатора
------------------------------------

**Базовые:**
1. Как в `ExtendibleHash.put()` реализована проверка переполнения?
   → Через `bucket.isFull()`. Если true и ключ новый, вызывается `split()`.

2. Как в `PerfectHash` гарантируется отсутствие коллизий?
   → Перебором случайных seed до успешной генерации таблицы.

3. Как в `MinHash` строится сигнатура?
   → В `signatureFor()`: для каждого элемента множества применяются все `numHash` функций, выбирается минимум.

4. Какие параметры задаются в бенчмарках MinHash?
   → numDocs, numHash, setSize, universe.

5. Для чего используется метод `printStatus()`?
   → Для отладки ExtendibleHash: показывает глобальную глубину, количество бакетов и их содержимое.

**Сложные:**
1. Почему в `ExtHashBucket` persist реализован через temp-файл и move?
   → Чтобы избежать "torn write" и обеспечить атомарность записи.

2. Какие данные сериализует метод `saveToFile()` в ExtendibleHash?
   → Объект `Meta`: bucketCapacity, globalDepth, storageDir, список имён бакетов, nextBucketId.

3. Почему в PerfectHash таблица создаётся размером n²?
   → Теоретическая гарантия высокой вероятности отсутствия коллизий.

4. Как MinHash связан с вероятностной оценкой Jaccard?
   → Вероятность совпадения минимальных хешей у двух множеств равна их Jaccard-сходству.

5. Как можно оптимизировать `ExtendibleHash` для ускорения вставок?
   → Использовать отложенную запись (batching), mmap, либо хранить журнал операций.